=== Pipeline Setup

This tutorial sets up a Tekton pipeline for building and deploying a application. We will use the `people` Quarkus application, i.e. the one that uses Quarkus Kafka extension. 
Since Tekton provides the ability to deploy applications to different clusters, we will use dedicated clusters for Dev and Prod. _OpenShift Pipelines Operator_ needs to be installed only on the Dev cluster.

The pipeline we will build will perform the following steps:

* Run application Unit tests
* Create a native build of the application using S2I
* Push the image to the external container registry (Quay)
* Deploy the application to Dev environment (dedicated Dev cluster)
* (Optional) Run integration tests
* Deploy the application to Prod environment (dedicated Prod cluster)

==== Initial set-up

Let's define the following environment variables in order to help us to customize our environments

INFO: Append `-<username>` to the OCP_PROD_NAMESPACE and OCP_DEV_NAMESPACE variable definition.

----
export OCP_PROD_CLUSTER={{OCP_PROD_CLUSTER}}
export OCP_DEV_CLUSTER={{OCP_DEV_CLUSTER}}
export OCP_PROD_NAMESPACE={{OCP_PROD_NAMESPACE}}
export OCP_DEV_NAMESPACE={{OCP_DEV_NAMESPACE}}
export OCP_DEV_KAFKA_NAMESPACE=<dev-kafka-namespace>
export USERNAME=<my_sso_username>
----


==== Download manifests

Please clone the Git repository mentioned below which contains all the necesarry manifests for creating the pipeline.

[source,sh,role="copypaste"]
----
git clone https://github.com/openlab-red/pipelines-catalog
----

==== Configure clusters and contexts

We will consider the following:

* {{OCP_AWS_CONSOLE}}[AWS] Cluster will be the *DEVELOPMENT* cluster, where we will build, test and deploy our app.
* {{OCP_BARE_CONSOLE}}[BareMetal] cluster will be the *PRODUCTION* one. Once the application is built and deployed to dev, we will deploy it to production as well.

Please go to the Dev and Prod cluster mentioned above and create a new projects for Dev and Prod

* on {{OCP_PROD_CONSOLE}}, create {{OCP_PROD_NAMESPACE}}
* on {{OCP_DEV_CONSOLE}}, create {{OCP_DEV_NAMESPACE}}


Then go to the terminal and login using *oc login* command obtained from the the console.

image::oc-login.png[oc-login,640,480]

image::oc-token.png[oc-token,320,240]

Please do this for *both clusters*.

Now, in order to be able to run commands against each of the clusters, you can switch the contexts using `oc config use-context <context-name>`
However, by default the generated context names are long and difficult to remember, so to make it easier to change the context later, use the following commands:

----
oc config get-contexts|grep ${OCP_DEV_CLUSTER}
oc config rename-context <contextname> dev
----

----
oc config get-contexts|grep ${OCP_PROD_CLUSTER}
oc config rename-context <contextname> prod
----

Then, to switch to dev cluster for example you'll need to run only `oc config use-context dev`.

Tekton pipelines will run only on Dev cluster, because on one side they are required for build and on the other side they provide the possibility to define a `cluster` resources where they will be able to deploy the application (in our case we will define the Bare metal cluster as the prod cluster).


#### Configure Prod environment

Tekton pipelines can be configured with `PipelineResources`, which can be used as inputs or outputs for the tasks in the pipeline. Example of `PipelineResources`: source, image, *cluster*.

A `cluster` resource is basically a definition of another OpenShift cluster and this can be referenced in the Pipeline tasks using KUBECONFIG.

In order to create a `cluster` resource, we will need to generate a secret on the Prod cluster which will contain: 
* The API URL of the Prod cluster
* The Namespace where the application will be deployed on Prod cluster
* The JWT token of the `pipeline` service account from the same Namespace
* Cluster CAFile

This secret will be consumed by the `cluster` PipelineResource.

To generate the secret, connect to Prod cluster and run `gen-secret-pipelineresource-prod-cluster.sh` script. 

[source,sh,role="copypaste"]
----
oc config use-context prod
----

[source,sh,role="copypaste"]
----
cd pipelines-catalog/quarkus
----

[source,sh,role="copypaste"]
----
bash gen-prod-manifests.sh ${OCP_PROD_CLUSTER} ${OCP_PROD_NAMESPACE}
----

The script will generate two files:

* `pipelineresource-prod-cluster.yaml`  -  Cluster PipelineResource
* `pipelineresource-prod-cluster-secret.yaml` - Secret for Cluster PipelineResource

We also need to create the initial deployment, service, route and imagestream as the pipeline will only rollout the new version of our application.

NOTE: Please replace <username> with your own username

[source,sh,role="copypaste"]
----
oc set image dc/people quarkus=quay.apps.ocp.bdmsky.net/$USERNAME/people:latest
----

The last thing we'll need to configure on prod would be customization of Quarkus `application.properties` configuration. This should be configured to use the same Kafka as in Dev(for the purpose of this lab)

[source,sh,role="copypaste"]
----
cat <<EOF | oc create -f 
kind: ConfigMap
apiVersion: v1
metadata:
  name: quarkus-config
  namespace: ${OCP_PROD_NAMESPACE}
data:
  application.properties: >-
    # drop and create the database at startup (use `update` to only update the
    schema)

    quarkus.hibernate-orm.database.generation=drop-and-create

    # Configure the Kafka sink (we write to it)

    %prod.mp.messaging.outgoing.generated-name.bootstrap.servers=names-cluster-kafka-bootstrap-kafka.${OCP_DEV_KAFKA_NAMESPACE}.${OCP_DEV_DOMAIN}:9094

    %prod.mp.messaging.outgoing.generated-name.connector=smallrye-kafka

    %prod.mp.messaging.outgoing.generated-name.topic=names

    %prod.mp.messaging.outgoing.generated-name.value.serializer=org.apache.kafka.common.serialization.StringSerializer


    # Configure the Kafka source (we read from it)

    %prod.mp.messaging.incoming.names.bootstrap.servers=names-cluster-kafka-bootstrap-kafka.${OCP_DEV_KAFKA_NAMESPACE}.${OCP_DEV_DOMAIN}:9094

    %prod.mp.messaging.incoming.names.connector=smallrye-kafka

    %prod.mp.messaging.incoming.names.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
EOF
----

[source,sh,role="copypaste"]
----
oc set volume dc/quarkus --add --overwrite --name=config --type=configmap --configmap-name=quarkus-config
 --mount-path=/home/quarkus/config
----

#### Configure Dev environment

Let's prepare the dev environment now.

First switch the context:

[source,sh,role="copypaste"]
----
oc config use-context dev
----

Since Tekton is still in *Dev Preview*, the Service Accounts it uses require high privileges. 
Then provide the required privileges to `pipeline` and `default` ServiceAccounts. 

[source,sh,role="copypaste"]
----
oc adm policy add-scc-to-user privileged -z pipeline && \
oc adm policy add-role-to-user edit -z pipeline && \
oc adm policy add-role-to-user edit -z default && \
oc adm policy add-scc-to-user privileged -z default && \
oc adm policy add-scc-to-user anyuid -z default
----

NOTE: The `pipeline` Service Account is created automatically in all the cluster namespaces after OpenShift Pipelines Operator is installed. It is used by Tekton to interact with OpenShift API.

As well as in prod, we need to create the initial resources.

NOTE: Please replace <username> with your own username

[source,sh,role="copypaste"]
----
oc set image dc/people quarkus=quay.apps.ocp.bdmsky.net/${USERNAME}/people:latest
----

Now it's time to create the Tekton resources.
First create `cluster` PipelineResource and the previously generated Secret.

[source,sh,role="copypaste"]
----
oc create -f pipelineresource-prod-cluster-secret.yaml
oc create -f pipelineresource-prod-cluster.yaml
----

After, create the `Tasks` resources. The following will be required for our pipeline:

* openshift-client - for deploying the app on the same cluster
* openshift-client-kubecfg - for deploying the app on a different cluster
* s2i-quarkus-task - for building the app with Quarkus S2I image
* mvn - for running unit tests

[source,sh,role="copypaste"]
----
oc apply -f openshift-client.yaml \
  -f openshift-client-kubecfg.yaml \
  -f s2i-quarkus-task.yaml \
  -f mvn.yaml
----

Check if the tasks were successfully created.

[source,sh,role="copypaste"]
----
tkn task ls
----

----
NAME                        AGE
openshift-client            13 seconds ago
openshift-client-kubecfg    13 seconds ago
s2i-quarkus                 13 seconds ago
mvn                         13 seconds ago
----

Next, create the `PipelineResources`:

NOTE: Replace <username> with your assigned user.

* the source git repo hosting the application. 

[source,sh,role="copypaste"]
----
cat <<EOF | oc create -f -
apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
  name: gogs
spec:
  type: git
  params:
    - name: url
      value: https://gogs.apps.ocp.bdmsky.net/${USERNAME}/quarkus-workshop
EOF
----

* the Docker repository for storing the image artifact

[source,sh,role="copypaste"]
----
cat <<EOF | oc create -f -
apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
  name: quay
spec:
  type: image
  params:
    - name: url
      value: "quay.apps.ocp.bdmsky.net/${USERNAME}/people:latest"
EOF
----

We will use one `Condition` resources in order to check if the app is already deployed. 

[source,sh,role="copypaste"]
----
oc create -f condition-deployed-prod.yaml
oc create -f condition-deployed-dev.yaml
----

Check if the resources were created

[source,sh,role="copypaste"]
----
oc get pipelineresource
----

----
NAME   AGE
gogs   12s
quay   10s
----

[source,sh,role="copypaste"]
----
oc get conditions
----

----
NAME            AGE
deployed-prod   38s
deployed-dev    38s
----


=== Deploy the pipeline

[source,bash]
----
oc create -f pipeline.yaml
----

Check of the pipeline was created

[source,bash]
----
oc get pipeline
----

```
NAME             AGE
quarkus-deploy   41s
```

From Developer Console > Pipelines

image::tektonpipeline[ Dev Pipeline ]

=== Launch the pipeline

[source,bash]
----
tkn pipeline start quarkus-deploy -p "APP_NAME=people"  -s pipeline
----

Or using Nexus

[source,bash]
----
tkn pipeline start quarkus-deploy -p "MAVEN_MIRROR_URL=http://nexus3.labs:8081/repository/maven-all-public/" -p "APP_NAME=people"  -s pipeline
----

```
? Choose the git resource to use for app-git: openlab-red (https://gogs.apps.ocp.bdmsky.net/<username>/quarkus-workshop)
? Choose the image resource to use for app-image: quarkus-internal-image (quay.apps.ocp.bdmsky.net/<username>/people:latest)
? Value of param `APP_NAME` ? (Default is quarkus) people
Pipelinerun started: quarkus-deploy-run-mww4f
Showing logs...
```

== Green

image::tektongreen.png[ Green Pipeline ]

== Verify

[source,bash]
----
oc get pod -lapp=people
----
