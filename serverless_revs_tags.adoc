### Revisions

First let's list the Knative services deployed

```
kn service list
```

Then, let's update the service deployed earlier.

```
kn service update hello --env TARGET=Kn
```

Now do a GET request to the service. You will notice it got updated

```
curl http://hello.<myuser-namespace>.{{OCP_DOMAIN}}
```

Each time a service gets updated, a new revision of is created with a new URL. That basically coincides with a creating a new Service and a new Deployment.

```
oc get svc
oc get deploy
```

Check also the current revisions

```
kn revision list

NAME            SERVICE   GENERATION   AGE     CONDITIONS   READY   REASON
hello-jlthg-2   hello     2            3m10s   3 OK / 4     True
hello-chjnf-1   hello     1            36m     3 OK / 4     True
```


### Traffic

Knative service allows for traffic mapping, which is the mapping of revisions of the service to an allocated portion of traffic. It offers the option to create unique URLs for particular revisions and has the ability to assign traffic to the latest revision.

With every update to the configuration of the service, a new revision is created with the service route pointing all the traffic to the latest ready revision by default.

You can change this behavior by defining which revision gets a portion of the traffic.

Now, let's route 10% of traffic to your new revision before putting all traffic on

```
kn service update hello --traffic @latest=10 --traffic hello-jlthg-2=90
```

Check the routes now

----
kn route list
----

And performing a GET request. You'll notice the service is pointing to the old revision, because 90% is routing to that revision.

```
curl  http://hello.<myuser-namespace>.{{OCP_DOMAIN}}
```

### Tagging

A tag in a traffic block of service creates a custom URL, which points to a referenced revision. A user can define a unique tag for an available revision of a service which creates a custom URL by using the format _*http(s)://TAG-SERVICE.DOMAIN*_

A given tag must be unique to its traffic block of the service. kn supports assigning and unassigning custom tags for revisions of services as part of the kn service update command

----
kn service update hello --tag @latest=candidate --tag hello-chjnf-1=current 
----

This commands creates two new routes based on the specified revisions. Let's check

----
curl http://current-hello.<myuser-namespace>.{{OCP_DOMAIN}}        
Hello Knativ!

curl http://candidate-hello.<myuser-namespace>.{{OCP_DOMAIN}}
Hello Kn!
----

### Scale out

Scaling achieved using Knative Serving Autoscaler. This is Kubernetes Deployment running a single Pod which watches request load on the Pods running user code. It increases and decreases the size of the Deployment running the user code in order to compensate for higher or lower traffic load.

You can specify the number of concurrent requests that should be handled by each instance of an application (revision container) by adding the  `target`  annotation or the  `containerConcurrency`  field in the revision template.
The `minScale` and `maxScale` annotations can be used to configure the minimum and maximum number of Pods that can serve applications. These annotations can be used to prevent cold starts or to help control computing costs. Using these annotations in the revision template will propagate this confguration to PodAutoscaler objects.

Let's create a new service using the concepts mentioned above.

----
cat <<EOF | oc create -f -
apiVersion: serving.knative.dev/v1alpha1
kind: Service
metadata:
  name: hello-scale
spec:
  template:
    metadata:
      annotations:
        # Target 10 requests in-flight per pod.
        autoscaling.knative.dev/target: "10"
        # Disable scale to zero with a minScale of 1.
        autoscaling.knative.dev/minScale: "1"
        # Limit scaling to 100 pods.
        autoscaling.knative.dev/maxScale: "100"
    spec:
      containers:
      - image: gcr.io/knative-samples/helloworld-go
EOF
----

The scaling parameters can be also defined using `kn` client.

----
kn service create hello-scale --image gcr.io/knative-samples/helloworld-go \
   --concurrency-limit 10 \
   --min-scale 1 \
   --max-scale 100 \
   --env TARGET=Knativ 
----

After creating the service, let's check its status
----
kn service list
curl http://hello-scale.<myuser-namespace>.{{OCP_DOMAIN}}
----

As `minScale` was set to 1, the deployment will always keep one running pod. Check the pods after 90 secods
----
oc get pods
----


#### Check HPA and generate some load
()

* monitoring

### References

* https://github.com/knative/serving/blob/master/docs/scaling/DEVELOPMENT.md
